1.背景介绍
    10多年时间过去了，今天的计算机仍然只能识别0和1，但由于最近10年内虚拟机以及大量建立在虚拟机之上的程
    序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，
    越来越多的程序语言选择了与  @操作系统和机器指令集无关的、 @平台中立  的格式作为程序编译后的存储格式
    （PS:字节码作为中立格式，最终被翻译成本地部署机器的native code 是由虚拟机来完成的)

2.关于"无关性"要点总结
    1.一次编写，到处运行（Write Once,Run Anywhere）,Sun公司以及其他虚拟机提供商发布了许多可以运行在
      @各种硬件架构不同平台  上的虚拟机，这些虚拟机都可以载入和执行  @同一种平台无关的字节码  ，从而实现了程序的
      “一次编写，到处运行”

    2.各种不同平台的虚拟机与所有平台都统一使用的  @程序存储格式——字节码（ByteCode） 是构成平台无关性的基石

    3.本节标题中刻意省略了“平台”二字，那是因为笔者注意到虚拟机的另外一种中立特性——语言无关性正越来越被开发者所重视

    4.@Java语言规范    和    @Java虚拟机规范

    5.@语言中立特性  在Java虚拟机发展到JDK 1.7～1.8的时候，被JVM设计者通过JSR-292基本兑现

    6.Clojure、 Groovy、 JRuby、 Jython、 Scala都可在java虚拟机 上执行
        【@由各自的编译器编译成字节码 .class文件，然后再由java虚拟机执行】
        【未来展望：Java虚拟机语言无关性能否超越平台无关性】

    7.语言无关性基础 -----  @虚拟机  和  @字节码存储格式
        7.1 Java虚拟机<===========>字节码，不考虑语言来源是否是Java
        7.2 出于安全考虑，Java虚拟机规范要求在Class文件中使用许多  @强制性的语法和结构化约束

    8.字节码描述能力强于Java语言，能Java所不能，为其他语言实现提供基础
          Java语言中的各种变量、 关键字和运算符号的语义最终都是由多条字节码命令组合而成的，
          因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大.因此，
          有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言
          实现一些有别于Java的语言特性提供了基础。


3.Class类文件的结构
    注意：任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接
       口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。 本章中，笔
       者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它
       并不一定以磁盘文件的形式存在

    class结构文件特点：

        1.是一组以8位字节为基础单位的二进制流，各个数据项目严格有序，紧凑排列，文件内容几乎全部是程序运行
          的必要数据

        2.当遇到需要占用8位字节以上空间的数据项时，则会按照  @高位在前  的方式分割成若干个8位字节进行存储

        3.采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表（后面的解析都以这两种类型为基础）

        4.无符号数属于基本的数据类型，以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个
          字节和8个字节的无符号数，无符号数可以用来描述  @数字、 @索引引用、 @数量值  或者按照UTF-8
          编码构成字符串值

        5.表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地
          以“_info”结尾。 表用于描述有层次关系的复合结构的数据，@整个Class文件本质上就是一张表

        6. @class表结构：imgs\class_structure.png


        7.无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一
          个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据
          为某一类型的集合。
          【例如 @class表结构 中的 methods, 前置的容量计数器：methods_count(u2类型);
          若干个连续的数据项：methods（method_info）】

        8.@class表结构不像XML等描述语言，它没有分隔符，所以class表结构中的数据项，无论是顺序还是数量，
            ，甚至于数据存储的字节序（Byte Ordering,Class文件中字节序为Big-Endian）这样的细节，
            都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变


魔数与Class文件的版本
    魔数：CA FE BA BE

    class文件的版本：紧接着魔数的4个字节存储的是Class文件的版本号
        1.第5和第6个字节是次版本号（Minor Version）
        2.第7和第8个字节是主版本号（Major Version）
        【主版本对照表：
            JDK 1.8 = 52
            JDK 1.7 = 51
            JDK 1.6 =50
            JDK 1.5 = 49
            JDK 1.4 = 48
            JDK 1.3 = 47
            JDK 1.2 = 46
            JDK 1.1 = 45
          】
        【注意：！！！高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文
            件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。】

常量池
    概述：
        主次版本号之后的是常量池入口,可被理解为Class文件之中的资源仓库【class表结构中有许多数据项会引用常量池】
        是占用class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目

    常量池中常量的数量表示：
        1.由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数
                  据，代表常量池容量计数值（constant_pool_count）。

        2.与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的，例如常量池容量（偏移地址：0x00000008）为十六
        进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。

        3.在Class文件格式规范制定之时，@设计者将第0项常量空出来是有特殊考虑的，这样做的目的在
        于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池
        项目”的含义，这种情况就可以把索引值置为0来表示。

        4.Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括@接口索引集合、 @字段表集合、 @方法表集合等的容量
        计数都与一般习惯相同，是从0开始的

    常量池存放数据类型：
        1.字面量（Literal）
            字面量比较接近于Java语言层面的常量概念,如文本字符串、 声明为final的常量值
        2.符号引用（Symbolic References）。
            字面量比较接近于Java语言层面的常量概念，如文本字符串、 声明为final的常量值等。 而符
            号引用则属于编译原理方面的概念，包括了下面三类常量：
                2.1 类和接口的全限定名（Fully Qualified Name）
                2.2 字段的名称和描述符（Descriptor）
                2.3 方法的名称和描述符

    虚拟机加载class文件：
        1.而是在虚拟机加载Class文件的时候进行动态连接。

        2.在Class文件中不会保存各个方法、 字段的最终内存布局信息，因此这些字段、
          方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。

        3.当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、 翻译到具体的内存地址之中

        4.class文件中的符号引用相当于记录相对信息？？？？


    常量池项目类型：imgs\constant_items.png

        CONSTANT_Class_info型常量结构:
            1.结构：imgs/CONSTANT_Class_info
                1.tag属性值：7【表示类或符号的接口引用】
                2.name_index: 是一个索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，
                              此常量代表了这个类（或者接口）的全限定名
        CONSTANT_Utf8_info型常量结构：
             1.结构：imgs/CONSTANT_Utf8_info
                            1.tag属性值：1【UTF-8编码的字符串】
                            2.length: 这个UTF-8编码的字符串长度是多少字节
                            3.bytes：字符串值的字节
        常量池结构总表：

访问标志
    在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息
    详见：imgs/class_access_flags.png

    access_flags中一共有16个标志位可以使用，当前只定义了其中8个[1]，没有使用到的标志
    位要求一律为0


