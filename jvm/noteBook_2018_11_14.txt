1.了解强引用，软引用，弱引用，虚引用
    强引用的特点：即使虚拟机执行强制回收，对象也不会被清除
    软引用的特点：内存充足时，即使虚拟机执行强制回收，对象也不会被清除；内存不足时，即使进行垃圾回收，也有可能内存溢出
    弱引用的特点：内存充足时，虚拟机执行强制回收，对象会被清除；
    虚引用的特点：丝毫不会影响对象的生命周期，无法通过引用获取其内部真正的对象实例；可以在当其引用的对象被回收时，发送一条消息给系统（ps:是什么样的消息呢）


2.老年代，新生代，survivor 和Eden代的区别和联系
    所以Java堆中还可以细分为：新生代和老年代；新生代再细致一点的有
    Eden空间、 From Survivor空间、 To Survivor空间

3.通过参数-XX：
  +HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆
  转储快照以便事后进行分析[1]。

4.方法区存储的东西
    主要用来存储class、运行时常量池、字段、方法、代码、JIT代码等。


7.safePoint和safe Region的区别（1）
    safePoint，引用不会发生变化的地方，同时也能保证应用程序较长时间执行的点。选取过少的话，GC占用的时间会很长；
    过多的话；应用程序执行效率会很慢。同时这个也说明了，一个方法体里面可能存在多个安全点，这些安全点将方法体分割
    成若干个代码段，每运行到一个safePoint时，JVM完成OopMap里面内容的更新工作，同时供Java虚拟机进行GC时作为参考
    使用。
    safe Region: 安全区域是指在一段代码片段中，引用关系不会发生变化，在该区域的任何地方发生GC都是安全的,相当于是
    safePoint的扩展

8.OopMap里面存放的是什么内容
    在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录着栈和寄存器中哪些位置是引用

9.不同的垃圾收集算法总结
    9.1 标记-清除”（Mark-Sweep）算法
        运作过程：
            首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
        缺点：
            1.效率问题，标记和清除两个过程的效率都不高；
            2.空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要
            分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
        优点：

    9.2 复制算法(老年代不适用这种算法，活的的对象很多)
        运作过程：
            它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着
            的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
        缺点：
            只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点
        优点：
            这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指
            针，按顺序分配内存即可，实现简单，运行高效
    9.3 标记-整理算法（适用于老年代）
        背景：
            复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。 更关键的是，如果不想浪费50%的空间，
            就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法
        运作流程：
            标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，
            然后直接清理掉端边界以外的内存

    9.4 复制算法改进版（适用于新生代）
        背景：
            新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间
            和两块较小的Survivor空间
        运作过程：
            每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最
            后清理掉Eden和刚才用过的Survivor空间