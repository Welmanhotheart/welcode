1.了解强引用，软引用，弱引用，虚引用
    强引用的特点：即使虚拟机执行强制回收，对象也不会被清除
    软引用的特点：内存充足时，即使虚拟机执行强制回收，对象也不会被清除；内存不足时，即使进行垃圾回收，也有可能内存溢出
    弱引用的特点：内存充足时，虚拟机执行强制回收，对象会被清除；
    虚引用的特点：丝毫不会影响对象的生命周期，无法通过引用获取其内部真正的对象实例；可以在当其引用的对象被回收时，发送一条消息给系统（ps:是什么样的消息呢）


2.老年代，新生代，survivor 和Eden代的区别和联系
    所以Java堆中还可以细分为：新生代和老年代；新生代再细致一点的有
    Eden空间、 From Survivor空间、 To Survivor空间

3.通过参数-XX：
  +HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆
  转储快照以便事后进行分析[1]。

4.方法区存储的东西
    主要用来存储class、运行时常量池、字段、方法、代码、JIT代码等。


7.safePoint和safe Region的区别（1）
    safePoint，引用不会发生变化的地方，同时也能保证应用程序较长时间执行的点。选取过少的话，GC占用的时间会很长；
    过多的话；应用程序执行效率会很慢。同时这个也说明了，一个方法体里面可能存在多个安全点，这些安全点将方法体分割
    成若干个代码段，每运行到一个safePoint时，JVM完成OopMap里面内容的更新工作，同时供Java虚拟机进行GC时作为参考
    使用。
    safe Region: 安全区域是指在一段代码片段中，引用关系不会发生变化，在该区域的任何地方发生GC都是安全的,相当于是
    safePoint的扩展

8.OopMap里面存放的是什么内容
    在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录着栈和寄存器中哪些位置是引用

9.不同的垃圾收集算法总结
    9.1 标记-清除”（Mark-Sweep）算法
        运作过程：
            首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
        缺点：
            1.效率问题，标记和清除两个过程的效率都不高；
            2.空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要
            分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
        优点：

    9.2 复制算法(老年代不适用这种算法，活的的对象很多)
        运作过程：
            它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着
            的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
        缺点：
            只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点
        优点：
            这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指
            针，按顺序分配内存即可，实现简单，运行高效
    9.3 标记-整理算法（适用于老年代）
        背景：
            复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。 更关键的是，如果不想浪费50%的空间，
            就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法
        运作流程：
            标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，
            然后直接清理掉端边界以外的内存

    9.4 复制算法改进版（适用于新生代）
        背景：
            新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间
            和两块较小的Survivor空间
        运作过程：
            每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，
            最后清理掉Eden和刚才用过的Survivor空间

    9.5 分代收集算法
        运作过程：
            只是根据对象存活周期的不同将内存划分为几块。 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
            在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
            而老年代中因为对象存活率高、 没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

10 Client模式
        定义：如果电脑只是运行一下Java程序，即是Client模式

10.各种垃圾收集器总结
    10.1 Serial收集器
        特点：“Stop The World”
        所针对的内存区域：有新生代，
        适用场景：它依然是虚拟机运行在Client模式下的默认新生代收集器。
        垃圾回收策略：它进行垃圾收集时，由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，直到它收集结束
        使用的垃圾收集算法：
        优点：对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

    10.2 ParNew收集器
        【ParNew收集器其实就是Serial收集器的多线程版本】
        特点：“Stop The World”，多线程收集，默认开启的收集线程与CPU数量一致
        所针对的内存区域：新生代，
        适用场景：多CPU多线程
        优点：
            随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的，目前只有它能与CMS收集器配合工作
        与Serial收集器的比较：
            ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在
            线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保
            证可以超越Serial收集器。 当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源
            的有效利用还是很有好处的。 它默认开启的收集线程数与CPU的数量相同，在CPU非常多

    10.3 Parallel Scavenge收集器
         特点：
         所针对的内存区域：新生代，
         适用场景：后台运算而不需要太多交互的任务。
         使用的垃圾收集算法：复制算法
         优点：高吞吐量
         与ParNew收集器的比较：都是并行
         与CMS收集器的比较：
            CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，
            而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）

    10.4 Serial Old收集器
        特点：单线程
        所针对的内存区域：老年代，
        适用场景：后台运算而不需要太多交互的任务。
        使用的垃圾收集算法：标记-整理
        优点：高吞吐量
        与ParNew收集器的比较：都是并行
        与CMS收集器的比较：



