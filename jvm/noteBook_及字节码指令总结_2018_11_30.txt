字节码指令介绍

    1. 定义及构成：Java虚拟机的指令由一个字节长度的、 代表着某种特定操作含义的数字（称为操作码，Opcode）
       以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。

       【不懂这段话：由于Java虚拟机采用面向操作数栈而不是寄存器的架构（这两种架构的区别和影响将在第8章中探讨），
       所以大多数的指令都不包含操作数，只有一个操作码】

    2.指令集特点
        1.缺点
            1.操作码总数不可能超过256条
                Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256条

            2.对于超过一个字节的数据，需要重新构造，损失性能
                占用字节由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些
                超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，如果要将一个
                16位长度的无符号整数使用两个无符号字节存储起来（将它们命名为byte1和byte2），那它
                们的值应该是这样的
                            （byte1＜＜8）|byte2
                这样执行字节码时，会损失性能

        2.优点，编译出的代码短小精干
            明显，放弃了操作数长度对齐[1]，就意味着可以省略很多填充和间隔符号；用一个字节来代
            表操作码，也是为了尽可能获得短小精干的编译代码。 这种追求尽可能小数据量、 高传输效
            率的设计是由Java语言设计之初面向网络、 智能家电的技术背景所决定的，并一直沿用至今。

    3.字节码与数据类型
        1.大多数的指令都包含了其操作所对应的数据类型信息，例如
            1.iload指令用于从局部变量表中加载int型的数据到操作数栈中，
            2.而fload指令加载的则是float类型的数据
        2.iload和fload这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，
            但在Class文件中它们必须拥有各自独立的操作码

        3.指令易记忆性，对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表
          明专门为哪种数据类型服务：
            1. i代表对int类型的数据操作，l代表long,s代表short,b代表byte,c代
               表char,f代表float,d代表double,a代表reference。
            2.也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，
                它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。

            3.还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的

        4.操作码长度为单字节带来的困难
            1.不同类型的指令之间互帮互助,共同应对不同类型的操作数
                1.1 指令数量有限，无法支持所有Java虚拟机运行时数据类型
                    如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，
                    那指令的数量恐怕就会超出一个字节所能表示的数量范围了

                1.2 对于特定的操作只提供了有限的类型相关指令去支持,即并非每种数据类型和每一种操作都有对应的指令
                    Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它

                1.3 需要时调兵谴将
                    有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。


            2.互帮互助举例
                【略】

    4.加载和存储指令
        加载和存储指令用于将数据在@栈帧中的局部变量表和@操作数栈（见第2章关于内存区域的介绍）之间来回传输，
        这类指令包括如下内容:
            1.将一个局部变量加载到操作栈：iload、 iload_＜n＞、 lload、 lload_＜n＞、 fload、 fload_
              ＜n＞、 dload、 dload_＜n＞、 aload、 aload_＜n＞

            2.将一个数值从操作数栈存储到局部变量表：istore、 istore_＜n＞、 lstore、 lstore_＜n＞、
              fstore、 fstore_＜n＞、 dstore、 dstore_＜n＞、 astore、 astore_＜n＞。

            3.将一个常量加载到操作数栈：bipush、 sipush、 ldc、 ldc_w、 ldc2_w、 aconst_null、
              iconst_m1、 iconst_＜i＞、 lconst_＜l＞、 fconst_＜f＞、 dconst_＜d＞

            4.扩充局部变量表的访问索引的指令：wide。

        存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还
            有少量指令，如  ！！！！@访问对象的字段或数组元素的指令  也会向操作数栈传输数据
