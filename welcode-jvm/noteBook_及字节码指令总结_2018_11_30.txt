字节码指令介绍

    1. 定义及构成：Java虚拟机的指令由一个字节长度的、 代表着某种特定操作含义的数字（称为操作码，Opcode）
       以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。

       【不懂这段话：由于Java虚拟机采用面向操作数栈而不是寄存器的架构（这两种架构的区别和影响将在第8章中探讨），
       所以大多数的指令都不包含操作数，只有一个操作码】

    2.指令集特点
        1.缺点
            1.操作码总数不可能超过256条
                Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256条

            2.对于超过一个字节的数据，需要重新构造，损失性能
                占用字节由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些
                超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，如果要将一个
                16位长度的无符号整数使用两个无符号字节存储起来（将它们命名为byte1和byte2），那它
                们的值应该是这样的
                            （byte1＜＜8）|byte2
                这样执行字节码时，会损失性能

        2.优点，编译出的代码短小精干
            明显，放弃了操作数长度对齐[1]，就意味着可以省略很多填充和间隔符号；用一个字节来代
            表操作码，也是为了尽可能获得短小精干的编译代码。 这种追求尽可能小数据量、 高传输效
            率的设计是由Java语言设计之初面向网络、 智能家电的技术背景所决定的，并一直沿用至今。

    3.字节码与数据类型
        1.大多数的指令都包含了其操作所对应的数据类型信息，例如
            1.iload指令用于从局部变量表中加载int型的数据到操作数栈中，
            2.而fload指令加载的则是float类型的数据
        2.iload和fload这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，
            但在Class文件中它们必须拥有各自独立的操作码

        3.指令易记忆性，对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表
          明专门为哪种数据类型服务：
            1. i代表对int类型的数据操作，l代表long,s代表short,b代表byte,c代
               表char,f代表float,d代表double,a代表reference。
            2.也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，
                它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。

            3.还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的

        4.操作码长度为单字节带来的困难
            1.不同类型的指令之间互帮互助,共同应对不同类型的操作数
                1.1 指令数量有限，无法支持所有Java虚拟机运行时数据类型
                    如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，
                    那指令的数量恐怕就会超出一个字节所能表示的数量范围了

                1.2 对于特定的操作只提供了有限的类型相关指令去支持,即并非每种数据类型和每一种操作都有对应的指令
                    Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它

                1.3 需要时调兵谴将
                    有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。


            2.互帮互助举例
                【略】

    4.加载和存储指令
        1. 加载和存储指令用于将数据在@栈帧中的局部变量表和@操作数栈（见第2章关于内存区域的介绍）之间来回传输，
           这类指令包括如下内容:
            1.将一个局部变量加载到操作栈：iload、 iload_＜n＞、 lload、 lload_＜n＞、 fload、 fload_
              ＜n＞、 dload、 dload_＜n＞、 aload、 aload_＜n＞

            2.将一个数值从操作数栈存储到局部变量表：istore、 istore_＜n＞、 lstore、 lstore_＜n＞、
              fstore、 fstore_＜n＞、 dstore、 dstore_＜n＞、 astore、 astore_＜n＞。

            3.将一个常量加载到操作数栈：bipush、 sipush、 ldc、 ldc_w、 ldc2_w、 aconst_null、
              iconst_m1、 iconst_＜i＞、 lconst_＜l＞、 fconst_＜f＞、 dconst_＜d＞

            4.扩充局部变量表的访问索引的指令：wide。

        2. 存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还
            有少量指令，如  ！！！！@访问对象的字段或数组元素的指令  也会向操作数栈传输数据

        3.指令簇的表示，举例如下：
            1.尖括号结尾的（ 例如iload_＜ n＞ ） ， 这些指令助记符实际上是代表了一组指令
              （ 例如iload_＜ n＞ ， 它代表了iload_0、 iload_1、 iload_2和iload_3这几条指令）。
              【ps:这几组指令都是某个带有一个操作数的通用指令（ 例如iload）的特殊形式】
        4.iload_＜ n＞（或者其他类似的指令）指令与操作数 的关系
            1.它们省略掉了显式的操作数， 不需要进行取操作数的动作，实际上操作数就隐含在指令中。

            2.它们的语义与原生的通用指令完全一致
            （ 例如iload_0的语义与操作数为0时的iload指令语义完全一致） 。 这种指令表示方法在本书
            以及《Java虚拟机规范》 中都是通用的。

    5.运算指令
        1.定义及功能：运算或算术指令用于对两个操作数栈上的值进行某种特定运算， 并把结果重新存入到@@操作栈顶。
        2.大体分类：可以分为两种，一是对整型数据进行运算的指令，二是对浮点型数据进行运算的指令，
        3.两种指令的共同点：都使用Java虚拟机的数据类型。
        4.没有直接支持的数据类型的：
          1.byte、short、 char和boolean类型的
          2.替代方法：对于这类数据的运算， 应使用操作int类型的指令代替。
        5.两种指令中被零除的算术指令的行为表现不同

        6.所有的算术指令如下。
            加法指令： iadd、 ladd、 fadd、 dadd。
            减法指令： isub、 lsub、 fsub、 dsub。
            乘法指令： imul、 lmul、 fmul、 dmul。
            除法指令： idiv、 ldiv、 fdiv、 ddiv。
            求余指令： irem、 lrem、 frem、 drem。
            取反指令： ineg、 lneg、 fneg、 dneg。
            位移指令： ishl、 ishr、 iushr、 lshl、 lshr、 lushr。
            按位或指令： ior、 lor。
            按位与指令： iand、 land。
            按位异或指令： ixor、 lxor。
            局部变量自增指令： iinc。
            比较指令： dcmpg、 dcmpl、 fcmpg、 fcmpl、 lcmp。

        7.运算时，数据溢出问题举例
            1.两个很大的正整数相加， 结果可能会是一个负数
                【ps:这种数学上不可能出现的溢出现象， 对于程序员来说是很容易理解的】

            2.但Java虚拟机规范没有明确定义过整型数据溢出的具体运算结果， 仅规定了在处理整型数据时，

            3.只有除法指令（ idiv和ldiv） 以及求余指令（ irem和lrem） 中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，
              其余任何整型数运算场景都不应该抛出运行时异常

        8.对于处理浮点数时，提出的要求
            Java虚拟机规范要求虚拟机实现在处理浮点数时， 必须严格遵循IEEE 754规范中所规定
            的行为和限制。 即：
                1.Java虚拟机必须完全支持IEEE 754中定义的  @非正规浮点数值
            （ Denormalized Floating-Point Numbers） 和@逐级下溢（ Gradual Underflow） 的运算规则。 这些
            特征将会使某些数值算法处理起来变得相对容易一些。
                2.Java虚拟机要求在进行浮点数运算时， 所有的运算结果都必须舍入到适当的精度， 非精确的结果必须舍入为可被表示的最接近的精确值，
                 如果有两种可表示的形式与该值一样接近， 将优先选择最低有效位为零的。 这种舍入模式也是IEEE 754规范中的默认舍入模式， 称为向最接近数舍入模式。

                3.不会抛出异常
                    另外， Java虚拟机在处理浮点数运算时， 不会抛出任何运行时异常（ 这里所讲的是Java
                    语言中的异常， 请读者勿与IEEE 754规范中的浮点异常互相混淆， IEEE 754的浮点异常是一
                    种运算信号） ， 当一个操作产生溢出时， 将会使用有符号的无穷大来表示， 如果某个操作结
                    果没有明确的数学定义的话， 将会使用NaN值来表示。 所有使用NaN值作为操作数的算术操
                    作， 结果都会返回NaN。
                    【ps, Java中 0.123/0.0 不会抛出异常， 执行结果是“-Infinity”】

        9.浮点数向整型转入时
            1.向零舍入模式，小数部分丢弃
                    在把浮点数转换为整数时， Java虚拟机使用IEEE 754标准中的向零舍入模式， 这种模式
                的舍入结果会导致数字被截断， 所有小数部分的有效字节都会被丢弃掉。 向零舍入模式将在
                目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。

    6.类型转换指令
        功能：类型转换指令可以将两种不同的数值类型进行相互转换， 这些转换操作一般用于实现用
        户代码中的  @显式类型转换操作， 或者用来处理本节开篇所提到的字节码指令集中数据类型相
        关指令无法与数据类型一一对应的问题

        1.宽化类型转换，即小范围类型向大范围类型的安全转换
            1.int类型到long、 float或者double类型。
            2.long类型到float、 double类型。
            3.float类型到double类型。
        2.窄类型转换，必须显式地使用转换指令来完成
            1.指令如下：
                i2b、 i2c、 i2s、 l2i、 f2i、 f2l、 d2i、 d2l和d2f
            2.导致后果
                1.转换结果产生不同的正负号
                    在将int或long类型窄化转换为整数类型T的时候， 转换过程仅仅是简单地丢弃除最低位N
                    个字节以外的内容， N是类型T的数据类型长度， 这将可能导致转换结果与输入值有不同的
                    正负号。 这点很容易理解， 因为原来符号位处于数值的最高位， 高位被丢弃之后， 转换结果
                    的符号就取决于低N个字节的首位了
                2.不同的数量级的情况， 转换过程很可能会导致数值的精度丢失

                3.在将一个浮点值窄化转换为整数类型T（ T限于int或long类型之一）,需遵守以下规则：
                    1.如果浮点值是NaN， 那转换结果就是int或long类型的0
                    2.如果浮点值不是无穷大的话， 浮点值使用IEEE 754的向零舍入模式取整， 获得整数值
                      v， 如果v在目标类型T（ int或long） 的表示范围之内， 那转换结果就是v。
                      否则， 将根据v的符号， 转换为T所能表示的最大或者最小正数。

                4.从double类型到float类型的窄化转换
                    向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。
                        1.如果转换结果的绝对值太小而无法使用float来表示的话， 将返回float类型的正负零。
                        2.如果转换结果的绝对值太大而无法使用float来表示的话， 将返回float类型的正负无穷大，
                        3.对于double类型的NaN值将按规定转换为float类型的NaN值。

        3.虚拟机对于窄化的处理
            尽管数据类型窄化转换可能会发生上限溢出、 下限溢出和精度丢失等情况， 但是Java虚
            拟机规范中明确规定数值类型的窄化转换指令  @@@永远不可能导致虚拟机抛出运行时异常!!!

    7. 对象创建与访问指令
        1.创建数组和类实例的字节码指令
            1.1 数组，newarray、 anewarray、 multianewarray
            1.2 类实例，new

        2.访问数组和类实例的字节码指令
            2.1 数组，newarray、 anewarray、 multianewarray
                1.把一个数组元素加载到操作数栈的指令： baload、 caload、 saload、 iaload、 laload、faload、 daload、 aaload。
                2. 将一个操作数栈的值存储到数组元素中的指令： bastore、 castore、 sastore、 iastore，fastore、 dastore、 aastore。
                3.取数组长度的指令： arraylength。
            2.2 类实例
                1. 访问类字段（ static字段， 或者称为类变量） : getstatic、 putstatic
                2. 访问实例字段（ 非static字段， 或者称为实例变量） 的指令： getfield、 putfield、
       3.检查类实例类型的指令： instanceof、 checkcast。

    8 操作数栈管理指令
          1. 将操作数栈的栈顶一个或两个元素出栈： pop、 pop2。
          2. 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶： dup、 dup2、dup_x1、 dup2_x1、 dup_x2、 dup2_x2。
          3. 将栈最顶端的两个数值互换： swap。

    9.控制转移指令
        1. 功能：控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序
        2. 如何理解：从概念模型上理解， 可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。
        3. 控制转移指令如下。
                1.条件分支： ifeq、 iflt、 ifle、 ifne、 ifgt、 ifge、 ifnull、 ifnonnull、 if_icmpeq、 if_icmpne、
                  if_icmplt、 if_icmpgt、 if_icmple、 if_icmpge、 if_acmpeq和if_acmpne。
                2.复合条件分支： tableswitch、 lookupswitch。
                3.无条件分支： goto、 goto_w、 jsr、 jsr_w、 ret。
                4.处理int和reference类型的条件分支比较操作
                    1.为了可以无须明显标识一个实体值是否null， 也有专门的指令用来检测null值。
                5. 对于boolean类型、 byte类型、 char类型和short类型的条分支比较操作，都是使用int类型的比较指令来完成
                6.对于long类型、 float类型和double类型的条件分支比较操作步骤，
                    1. 执行相应类型的比较运算指令（ dcmpg、 dcmpl、 fcmpg、fcmpl、 lcmp) ， 获取返回的整型值到操作数栈中
                    2. 随后再执行int类型的条件分支比较操作来完成整个分支跳转。
        4.由于各种类型的比较最终都会转化为int类型的比较操作， int类型比较是否方便完善就显得尤为重要， 所以Java虚拟机提供的int类型的条件分支
          指令是最为丰富和强大的。

    10.方法调用和返回指令

       1. invokevirtual指令用于调用对象的实例方法， 根据对象的实际类型进行分派（ 虚方法分派） ， 这也是Java语言中最常见的方法分派方式。

       2. invokeinterface指令用于调用接口方法， 它会在运行时搜索一个实现了这个接口方法的对象， 找出适合的方法进行调用。

       3. invokespecial指令用于调用一些需要特殊处理的实例方法， 包括实例初始化方法、 私有方法和父类方法。

       4. invokestatic指令用于调用类方法（ static方法） 。

       5. invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法， 并执行该方法

       6. 1~4 与 5的区别
          1.前面4条调用指令的分派逻辑都固化在Java虚拟机内部， 而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

       7.数据类型无关性
            1. 方法调用指令与数据类型无关， 而方法返回指令是根据返回值的类型区分的， 包括ireturn
                （ 当返回值是boolean、 byte、 char、 short和int类型时使用） 、 lreturn、 freturn、 dreturn和areturn，
            2.return指令供声明为void的方法、 实例初始化方法以及类和接口的类初始化方法使用。

    11.异常处理指令
        1.Java中显示抛出异常的操作：throw语句
        2.对应的指令：athrow
        3.Java中自动抛出异常的情形，举例
            1. 整数运算中， 当除数为零时， 虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。
        4.Java虚拟机中如何处理异常采用异常表来完成的。

    12.同步指令
       1. Java虚拟机可以支持 方法级同步，方法内部一段指令序列
       2.这两种同步结构都是使用管程（ Monitor） 来支持的。
       3.两种同步的
           3.1 方法级同步
                1.特点：同步隐式的， 即无须通过字节码指令来控制，
                2.实现：
                    1.实现scope:它实现在方法调用和返回操作之中。
                    2.步骤：
                        1.虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个
                          方法是否声明为同步方法。
                        2.当方法调用时， 调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，
                        3.如果设置了， 执行线程就要求先成功持有管程， 然后才能执行方法
                        4.最后当方法完成（ 无论是正常完成还是非正常完成） 时释放管程。
                3.管程争夺
                    1.只能被一个线程在某一时刻拥有
                        在方法执行期间， 执行线程持有了管程， 其他任何线程都无法再获取到同一个管程。
                    2.如果一个同步方法执行期间抛出了异常， 并且在方法内部无法处理此异常， 那么这个同步方法所持有的管程将在异常抛到同
                      步方法之外时自动释放。
           3.2 指令集同步
               1.特点：非隐式的
                    Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义
               2.在java语言中如何实现
                    同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的

               3.正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，

