1.如何实现fConstr 继承 fsuperConstr
	1.构造中间构造函数: var f = function(){};
	2.令f的原型指向基类的原型: f.prototype = fSuperConstr.prototype;
	3.fConstr的_superClass属性记录: fConstr._superClass = fSuperConstr;
	4.让fConstr的原型指向f的一个实例: var p = fConstr.prototype = new f();
		
		if (sName) {
			p._className = sName;
		}
	5.让fConstr的原型的构造函数重新指向fConstr:	p.constructor = fConstr;

	效果：var finstance = new fConstr();
	finstance._proto_ = p = new f();
	p._proto_ = fSuperConstr.prototype;
	
	原型链: finstance._proto_._proto_ 
	
2.防止多重复操作模型：
	function() {
		if (this.fireFilterTimeout) {
			clearTimeout(this.fireFilterTimeout);
			this.fireFilterTimeout = 0;
		}
		this.fireFilterTimeout = setTimeout(function(){
			this.fireFilterTimeout = null;
			 //TODO
		}.bind(this), 800);
	}

3.监听器思想：
	//全局对象装载器
	var globalEventMap = {};
	
	function A() {
		// A 注册事件,并监听
		addEvent(eventKey, function(arguments) {
			//TODO
		});
	}
	
	function B() {
		//B 发送事件通知A
		fireEvent(eventKey, arguments);
	}
	
	function addEvent(eventKey, eventFunc) {
		globalEventMap.eventKey = eventFunc;
	}
	
	function fireEvent(eventKey,arguments) {
		var func = globalEventMap[eventKey];
		func.apply(null, arguments);
	}

4.对象之闭包
	(function(passedArguments) {
		//TODO
	};)(outerArguments);