1.了解普通对象指针压缩功能（-XX:+UseCompressedOops）
	通常64位JVM消耗的内存会比32位的大1.5倍，这是因为对象指针在64位架构下，长度会翻倍（更宽的寻址）。
	对于那些将要从32位平台移植到64位的应用来说，平白无辜多了1/2的内存占用，这是开发者不愿意看到的。
	幸运的是，从JDK 1.6 update14开始，64 bit JVM正式支持了 -XX:+UseCompressedOops
	 这个可以压缩指针，起到节约内存占用的新参数。
	 [问题，1.5倍怎么来的]
2.了解数据类型对齐补白
	JVM在创建对象的时候，会有一个内存对齐的概念；如
	1、 一个空对象占用8字节( 空对象：占8字节 64位bit )
	2、 只有一个 boolean 字段的类实例占 16 字节：头信息占 8 字节，boolean 占 1 字节，为了对齐达到 8 的倍数会额外占用 7 个字节
	3、 包含 8 个 boolean 字段的实例也会占用 16 字节：头信息占用 8 字节，boolean 占用 8 字节；因为已经是 8 的倍数，不需要补充额外的数据来对齐
	4、 一个包 2个 long 字段、3个 int字段、1 个 boolean 字段的对象将占用:
	头信息占 8 字节;
	2 个 long 字段占 16 字节（每个 long 字段占用 8 字节）;
	3 个 int 字段占 12 字节（每个 int 字段占用 4 字节）;
	1 个 boolean 字段占 1 个字节；
	上面加起来是 37 字节，
	为了对齐额外多的 3 个字节，需求对齐 ，为8 的倍数 40
--------------------- 
3.了解java.util.concurrent.forkjoin及Fork/Join模式
	Java在JDK7之后加入了并行计算的框架Fork/Join，可以解决我们系统中大数据计算的性能问题。
	Fork/Join采用的是分治法，Fork是将一个大任务拆分成若干个子任务，子任务分别去计算，
	而Join是获取到子任务的计算结果，然后合并，这个是递归的过程。子任务被分配到不同的核上执行时，效率最高。
	
4.了解CPU，显卡，GPU，APU的区别和联系
	CPU由
	4.1 控制单元（指令计数器（IC、Instruction Counter）、
	指令寄存器（IR、Instruction Register）、指令译码器（ID、Instruction Decoder）
	和操作控制器（OC、Opreater））；
	4.2存储单元（内缓存寄存器和寄存器）
	4.3运算单元
	
5.了解标准编译和OSR（栈上替换）https://www.cnblogs.com/insistence/p/5901457.html
6.了解两级即时编译器 https://www.cnblogs.com/insistence/p/5901457.html